---
title: 升级至 3.0 版本
description: 将应用中的 Capacitor 从 v2 升级到 v3 的指南
slug: /updating/3-0
---

# 将应用升级至 Capacitor 3.0

Capacitor 3 为生态系统带来了重要更新和令人兴奋的新功能。

[阅读 Capacitor 3.0 发布公告 &#8250;](https://ionicframework.com/blog/announcing-capacitor-3-0/)

> 将应用升级至 Capacitor 3 后，欢迎在[此讨论区](https://github.com/ionic-team/capacitor/discussions/3994)分享您的反馈意见。我们期待听到您的声音！💖

如果您是插件开发者，需要将插件升级至新版 Capacitor，请参阅[Capacitor 插件升级指南](/main/updating/plugins/3-0.md)。

## 需 NodeJS 12+

Node 8 已终止支持。Node 10 将于 2021 年 4 月 30 日终止支持。Capacitor 3 要求 NodeJS 12 或更高版本（推荐使用最新的 LTS 版本）。

## Ionic CLI

如果您使用 Ionic CLI，官方对 Capacitor 3 的支持从版本 6.16.0 开始。建议通过 `npm install -g @ionic/cli` 升级至最新版本。

## 更新 Capacitor CLI 和核心库

```bash
npm install @capacitor/cli@latest-3 @capacitor/core@latest-3
```

## 支持 ES2017+

Capacitor 3 现在构建目标是 ES2017 环境，而非 ES5。[插件模板也已更新](https://github.com/ionic-team/capacitor/pull/3427/files#diff-b22b3d0cbb7d8f6fdfe1f6f1d9e84b7d)为 ES2017，鼓励第三方插件也更新其构建目标。

除非您需要支持 IE11（Capacitor 官方不支持的浏览器），否则此变更不会影响您的应用。

## TypeScript 3.8+

Capacitor 3 使用了需要 TS 3.8 或更高版本的新 TypeScript 语法。

## Capacitor 配置变更

如果已安装 TypeScript 3.8+，您可以将 `capacitor.config.json` 迁移为类型化的 TypeScript 配置文件 `capacitor.config.ts`。您仍可使用 `.json` 文件，但 TypeScript 配置文件能为团队提供更好的开发体验。以下是 [Capacitor 测试应用](https://github.com/ionic-team/capacitor-testapp)中使用的 `capacitor.config.ts` 示例：

```typescript
/// <reference types="@capacitor/local-notifications" />
/// <reference types="@capacitor/push-notifications" />
/// <reference types="@capacitor/splash-screen" />

import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.capacitorjs.app.testapp',
  appName: 'capacitor-testapp',
  webDir: 'build',
  plugins: {
    SplashScreen: {
      launchAutoHide: false,
    },
    LocalNotifications: {
      smallIcon: 'ic_stat_icon_config_sample',
      iconColor: '#CE0B7C',
    },
    PushNotifications: {
      presentationOptions: ['alert', 'sound'],
    },
  },
};

export default config;
```

## 官方插件

所有插件已从 Capacitor 核心库中移除，并分别发布为独立的 npm 包。这有多方面原因（参见 [#3227](https://github.com/ionic-team/capacitor/issues/3227)），核心团队确信这是正确的方向。您可以这样导入核心插件：

```typescript
import { Camera } from '@capacitor/camera';
```

### 移除的任务、权限和相册插件

- **后台任务**：该插件使用率低且功能不符合大多数开发者预期。核心团队将在未来重新设计后台功能。关注 [#3032](https://github.com/ionic-team/capacitor/issues/3032) 获取更新。
- **权限**：核心团队实现了替代方案（参见[新权限 API](/plugins/creating-plugins/web-guide.md#permissions)），社区插件也可采用。
- **相册**：这个未公开文档的 iOS 专属插件已被移除。建议使用 [`@capacitor-community/media`](https://github.com/capacitor-community/media)。

### 拆分辅助功能 应用和模态窗口插件

- **辅助功能**
  - VoiceOver 和 TalkBack 功能移至 [**屏幕阅读器**](/apis/screen-reader.md)
- **应用**
  - 应用相关信息与功能保留在 [**应用**](/apis/app.md)
  - 应用 URL 处理（`openUrl()` 和 `canOpenUrl()`）移至 [**应用启动器**](/apis/app-launcher.md)
- **模态窗口**
  - 操作表功能（`showActions()`）移至 [**操作表**](/apis/action-sheet.md)
  - 对话框功能（`alert()`、`prompt()` 和 `confirm()`）移至 [**对话框**](/apis/dialog.md)

### 迁移应用使用新的官方插件包

此变更需要您单独安装每个使用的插件：

1. 在项目中搜索从 `@capacitor/core` 的 `Plugins` 对象导入的核心插件
1. 查找对应的[插件文档](/plugins/official.md)，注意[部分插件已被拆分](#拆分辅助功能-应用和模态窗口插件)
1. 按照文档中的安装说明操作
1. 将插件导入改为从插件包导入（参见[插件导入](#插件导入)）
1. 遵循[向后不兼容的插件变更](#向后不兼容的插件变更)中的说明

**使用 Ionic 框架？**

Ionic 框架使用了以下插件的 API：

- [**应用**](/apis/app.md)
- [**触觉反馈**](/apis/haptics.md)
- [**键盘**](/apis/keyboard.md)
- [**状态栏**](/apis/status-bar.md)

为获得最佳 Ionic 框架用户体验，即使未在应用中直接导入这些插件，也应确保它们已安装：

```bash
npm install @capacitor/app @capacitor/haptics @capacitor/keyboard @capacitor/status-bar
```

## 插件导入

`Plugins` 对象已被弃用，但在 Capacitor 3 中仍可工作。Capacitor 插件应更新以使用新的插件注册 API（参见[插件升级指南](/main/updating/plugins/3-0.md)），这将允许直接从插件包导入。

今后不应再使用 `@capacitor/core` 中的 `Plugins` 对象。

```typescript
// 旧方式
import { Plugins } from '@capacitor/core';
const { AnyPlugin } = Plugins;
```

推荐直接从插件包导入插件，但插件必须更新以适配 Capacitor 3 才能实现：

```typescript
// 新方式
import { AnyPlugin } from 'any-plugin';
```

## 向后不兼容的插件变更

虽然许多插件 API 保持不变以简化迁移过程，但有些需要代码更新和手动迁移：

- **辅助功能** / **屏幕阅读器**
  - `isScreenReaderEnabled()` 方法重命名为 `isEnabled()`
  - `'accessibilityScreenReaderStateChange'` 事件重命名为 `'stateChange'`
  - 在 Android 和 iOS 上，`speak()` 仅在屏幕阅读器激活时工作。如需无论屏幕阅读器是否激活都能使用的文本转语音功能，请使用 [`@capacitor-community/text-to-speech`](https://github.com/capacitor-community/text-to-speech)。
- **浏览器**
  - 移除了 `prefetch()`。
- **设备**
  - 从 `getInfo()` 移除了应用信息（`appVersion`、`appBuild`、`appId` 和 `appName`）。使用应用插件的 [`getInfo()`](/apis/app.md#getinfo) 获取这些信息。
  - 从 `getInfo()` 移除了 `uuid`。使用新的 `getId()` 函数。
- **触觉反馈**
  - `HapticsNotificationType` 枚举键从大写改为驼峰式以匹配其他枚举。
- **本地通知**
  - 此插件现在使用新的权限 API。移除了 `requestPermission()`，改用 `requestPermissions()`。
- **推送通知**
  - 此插件现在使用新的权限 API。移除了 `requestPermission()`，改用 `requestPermissions()`。
- **分享**
  - `share()` 方法现在返回 `ShareResult` 而非 `any`
  - `share()` 的返回值不再包含 `completed`。如果未完成，将直接拒绝。
- **存储**
  - **需要数据迁移！** 内部存储机制已变更，需要数据迁移。已添加便利方法 `migrate()`。要在不影响最终用户的情况下更新应用，在其他方法之前调用 `migrate()`。
- **文件系统**
  - `stat()` 方法现在在所有平台上返回以毫秒为单位的 ctime 和 mtime 时间戳。此前 iOS 返回的时间戳单位为秒。

## 日志记录变更

Capacitor 3 中已弃用 `hideLogs` 配置选项，替换为新的 `loggingBehavior` 配置选项。详情参见[配置文档](/main/reference/config.md)。

## iOS

Capacitor 3 支持 iOS 12+。需要 Xcode 12+。推荐 CocoaPods 1.8+。

### 更新 CocoaPods

建议升级至最新稳定版 CocoaPods。[CocoaPods 1.8](https://blog.cocoapods.org/CocoaPods-1.8.0-beta/) 改用 CDN，不再需要定期运行 `pod repo update`。

使用 `pod --version` 检查 CocoaPods 版本，访问 [cocoapods.org](https://cocoapods.org) 获取安装说明。

### 设置 iOS 部署目标为 12.0

在 Xcode 项目和应用的 **Build Settings** 标签页下，**Deployment** 部分中将 **iOS Deployment Target** 改为 **iOS 12.0**。

然后，打开 `ios/App/Podfile` 并将 iOS 版本更新为 12.0：

```diff
-platform :ios, '11.0'
+platform :ios, '12.0'
 use_frameworks!
```

### 设置 Swift 版本为 5

如果应用尚未使用 Swift 5，在 Xcode 目标的 **Build Settings** 标签页中，**Swift Compiler - Language** 部分将 **Swift Language Version** 改为 **Swift 5**。

### 将 `public` 移至 iOS 目标目录

Capacitor 3 推荐将 `ios/App/public` 目录移动到 `ios/App/App/public`。可在 Xcode 中操作：

**删除现有 `public` 文件夹**

1. 展开 `App` 项目下的文件树，选择 `App` 组中的 `public` 文件夹
1. 右键点击 **Delete**。当提示删除文件夹或仅移除引用时，选择 **Move to Trash**

![删除 public 文件夹](../../../../static/img/v3/docs/ios/xcode-public-delete-folder.png)

**在新位置重建 `public`**

1. 右键点击 `App` 项目中的 `App` 组，选择 **Add Files to "App"...**
1. 保留默认选项（确保创建文件夹引用而非组，并添加到 `App` 目标）
1. 点击 **New Folder**，命名为 "public"
1. 点击 **Create**，然后 **Add**

![重建 public 文件夹](../../../../static/img/v3/docs/ios/xcode-public-new-folder.png)

Xcode 中显示可能相同，但新的 `public` 文件夹现在应相对于 `App` 组而非项目根目录。

**gitignore 新的 `public` 文件夹**

在 `ios/.gitignore` 中，将忽略路径从 `App/public` 改为 `App/App/public`。此文件夹包含您的 web 资源副本，不应提交。

```diff
 App/build
 App/Pods
-App/public
+App/App/public
 App/Podfile.lock
 xcuserdata
```

### 更新 Capacitor iOS 平台

```bash
npm install @capacitor/ios@latest-3
npx cap sync ios
```

### 将应用事件从 `CAPBridge` 切换到 `ApplicationDelegateProxy`

在 `ios/App/App/AppDelegate.swift` 中更新：

```diff
     func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
         // Called when the app was launched with a url. Feel free to add additional processing here,
         // but if you want the App API to support tracking app url opens, make sure to keep this call
-        return CAPBridge.handleOpenUrl(url, options)
+        return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
     }

     func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
         // Called when the app was launched with an activity, including Universal Links.
         // Feel free to add additional processing here, but if you want the App API to support
         // tracking app url opens, make sure to keep this call
-        return CAPBridge.handleContinueActivity(userActivity, restorationHandler)
+        return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
     }
```

### 移除 USE_PUSH 编译条件

如果使用推送通知功能，在 `ios/App/App/AppDelegate.swift` 中更新：

```diff

-    #if USE_PUSH

     func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
     }

     func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
     }

-#endif
```

如果不使用推送通知，可移除整个代码块：

```diff
-    #if USE_PUSH
-
-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
-    }
-
-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
-    }
-
-#endif
```

### 从硬编码 `CAPNotifications` 切换到 `NSNotification` 扩展

在 `ios/App/App/AppDelegate.swift` 中更新：

```diff
     override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
         super.touchesBegan(touches, with: event)

         let statusBarRect = UIApplication.shared.statusBarFrame
         guard let touchPoint = event?.allTouches?.first?.location(in: self.window) else { return }

         if statusBarRect.contains(touchPoint) {
-            NotificationCenter.default.post(CAPBridge.statusBarTappedNotification)
+            NotificationCenter.default.post(name: .capacitorStatusBarTapped, object: nil)
         }
     }

     func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
+        NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
     }

     func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
+        NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
     }
```

### 忽略 `DerivedData`

在 `ios/.gitignore` 文件中添加 `DerivedData`。这是 Capacitor CLI 放置原生 iOS 构建的位置。

```diff
 App/Pods
 App/App/public
 App/Podfile.lock
+DerivedData
 xcuserdata

 # Cordova plugins for Capacitor
```

## Android

Capacitor 3 支持 Android 5+（现支持 Android 11）。需要 Android Studio 4+。

### 更新 Capacitor Android 平台

```bash
npm install @capacitor/android@latest-3
npx cap sync android
```

### 切换至自动加载 Android 插件

在 Capacitor 3 中，推荐自动加载 Android 插件。在 `MainActivity.java` 中，可移除 `onCreate` 方法。添加或移除通过 npm 安装的插件时，不再需要编辑此文件。

```diff
 public class MainActivity extends BridgeActivity {
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        // Initializes the Bridge
-        this.init(savedInstanceState, new ArrayList<Class<? extends Plugin>>() {{
-            // Additional plugins you've installed go here
-            add(Plugin1.class);
-            add(Plugin2.class);
-        }});
-    }
 }
```

如果应用中包含专门为应用构建的自定义插件，仍需在 `onCreate` 中注册：

```diff
 public class MainActivity extends BridgeActivity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

+        registerPlugin(PluginInMyApp.class);
     }
 }
```

### 更新 Gradle 至 7.0

现在推荐在 Capacitor 项目中使用 Gradle 7.0。在 Android Studio 中，打开 **File** 菜单，点击 **Project Structure**。在 **Project** 部分，将 **Gradle Version** 改为 \*\*7
