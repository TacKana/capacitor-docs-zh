---
title: 升级到 3.0 版本
description: 将应用中的 Capacitor 从 v2 升级至 v3 的指南
slug: /updating/3-0
---

# 将应用中的 Capacitor 升级至 3.0

Capacitor 3 为生态系统带来了关键更新和令人兴奋的新功能。

[阅读 Capacitor 3.0 发布公告 &#8250;](https://ionicframework.com/blog/announcing-capacitor-3-0/)

> 将应用升级到 Capacitor 3 后，您是否愿意在[此讨论区](https://github.com/ionic-team/capacitor/discussions/3994)分享反馈？我们非常期待您的意见！💖

如果您是插件开发者，希望将插件升级至新版 Capacitor，请参阅[Capacitor 插件升级指南](/main/updating/plugins/3-0.md)。

## NodeJS 12+

Node 8 已终止支持。Node 10 将在 2021 年 4 月 30 日终止支持。Capacitor 3 需要 NodeJS 12 或更高版本（推荐使用最新的 LTS 版本）。

## Ionic CLI

如果您使用 Ionic CLI，官方对 Capacitor 3 的支持从版本 6.16.0 开始。建议通过 `npm install -g @ionic/cli` 升级至最新版本。

## 更新 Capacitor CLI 和核心库

```bash
npm install @capacitor/cli@latest-3 @capacitor/core@latest-3
```

## ES2017+

Capacitor 3 现在针对 ES2017 环境构建，而非 ES5。[插件模板也已更新](https://github.com/ionic-team/capacitor/pull/3427/files#diff-b22b3d0cbb7d8f6fdfe1f6f1d9e84b7d)以面向 ES2017，鼓励第三方插件更新其目标环境。

除非您需要支持 IE11（Capacitor 官方不支持），否则此变更不应影响您的应用。

## TypeScript 3.8+

Capacitor 3 使用了新版 TypeScript 语法，仅支持 TS 3.8 或更高版本。

## Capacitor 配置变更

如果已安装 TypeScript 3.8+，您可以将 `capacitor.config.json` 迁移为类型化的 TypeScript 配置文件 `capacitor.config.ts`。您仍可使用 `.json` 文件，但 TypeScript 配置文件能为团队提供更好的开发体验。以下是 [Capacitor 测试应用](https://github.com/ionic-team/capacitor-testapp)中使用的 `capacitor.config.ts` 示例：

```typescript
/// <reference types="@capacitor/local-notifications" />
/// <reference types="@capacitor/push-notifications" />
/// <reference types="@capacitor/splash-screen" />

import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.capacitorjs.app.testapp',
  appName: 'capacitor-testapp',
  webDir: 'build',
  plugins: {
    SplashScreen: {
      launchAutoHide: false,
    },
    LocalNotifications: {
      smallIcon: 'ic_stat_icon_config_sample',
      iconColor: '#CE0B7C',
    },
    PushNotifications: {
      presentationOptions: ['alert', 'sound'],
    },
  },
};

export default config;
```

## 官方插件

所有插件已从 Capacitor 核心库中移除，并分别发布为 npm 包。这样做的原因有多方面（参见 [#3227](https://github.com/ionic-team/capacitor/issues/3227)），核心团队确信这是正确的方向。您可以按以下方式导入核心插件：

```typescript
import { Camera } from '@capacitor/camera';
```

### 移除了后台任务、权限和照片插件

- **后台任务**：该插件似乎很少使用，且功能与大多数开发者的预期不符。核心团队未来将重新设计后台功能。关注 [#3032](https://github.com/ionic-team/capacitor/issues/3032) 获取更新。
- **权限**：核心团队已实现了一种替代方案（参见[新版权限 API](/plugins/creating-plugins/web-guide.md#permissions)），社区插件也可采用。
- **照片**：这个未公开文档的 iOS 专属插件已被移除。请使用 [`@capacitor-community/media`](https://github.com/capacitor-community/media)。

### 拆分辅助功能、应用和模态框插件

- **辅助功能**
  - VoiceOver 和 TalkBack 功能移至 [**屏幕阅读器**](/apis/screen-reader.md)
- **应用**
  - 应用相关信息和功能保留在 [**应用**](/apis/app.md)
  - 应用 URL 处理（`openUrl()` 和 `canOpenUrl()`）移至 [**应用启动器**](/apis/app-launcher.md)
- **模态框**
  - 操作表功能（`showActions()`）移至 [**操作表**](/apis/action-sheet.md)
  - 对话框功能（`alert()`、`prompt()` 和 `confirm()`）移至 [**对话框**](/apis/dialog.md)

### 迁移应用以使用新版官方插件包

此变更要求您单独安装每个正在使用的插件。

1. 在项目中搜索从 `@capacitor/core` 的 `Plugins` 对象中提取的核心插件
1. 查找对应的[插件文档](/plugins/official.md)，注意[部分插件已被拆分](#拆分辅助功能应用和模态框插件)
1. 按照文档中的安装说明操作每个插件
1. 将插件导入改为从插件包导入（参见[插件导入](#插件导入)）
1. 遵循[向后不兼容的插件变更](#向后不兼容的插件变更)中的说明

**使用 Ionic Framework？**

Ionic Framework 使用了以下插件中的 API：

- [**应用**](/apis/app.md)
- [**触觉反馈**](/apis/haptics.md)
- [**键盘**](/apis/keyboard.md)
- [**状态栏**](/apis/status-bar.md)

为了在 Ionic Framework 中获得最佳用户体验，即使您未在应用中导入这些插件，也应确保它们已安装：

```bash
npm install @capacitor/app @capacitor/haptics @capacitor/keyboard @capacitor/status-bar
```

## 插件导入

`Plugins` 对象已弃用，但在 Capacitor 3 中仍可工作。Capacitor 插件应更新以使用新版插件注册 API（参见[插件升级指南](/main/updating/plugins/3-0.md)），这将允许直接从插件包导入插件。

今后，不应再使用来自 `@capacitor/core` 的 `Plugins` 对象。

```typescript
// 旧方式
import { Plugins } from '@capacitor/core';
const { AnyPlugin } = Plugins;
```

直接从插件包导入插件是推荐做法，但插件必须更新至 Capacitor 3 才能支持此方式。

```typescript
// 新方式
import { AnyPlugin } from 'any-plugin';
```

## 向后不兼容的插件变更

虽然许多插件 API 保持不变以简化迁移过程，但部分 API 需要代码更新和手动迁移。

- **辅助功能** / **屏幕阅读器**
  - `isScreenReaderEnabled()` 方法重命名为 `isEnabled()`
  - `'accessibilityScreenReaderStateChange'` 事件重命名为 `'stateChange'`
  - 在 Android 和 iOS 上，`speak()` 仅在屏幕阅读器激活时有效。如需在屏幕阅读器激活与否时都能使用文本转语音功能，请使用 [`@capacitor-community/text-to-speech`](https://github.com/capacitor-community/text-to-speech)。
- **浏览器**
  - 移除了 `prefetch()`。
- **设备**
  - 从 `getInfo()` 移除了应用信息（`appVersion`、`appBuild`、`appId` 和 `appName`）。使用应用插件的 [`getInfo()`](/apis/app.md#getinfo) 获取这些信息。
  - 从 `getInfo()` 移除了 `uuid`。使用新的 `getId()` 函数。
- **触觉反馈**
  - `HapticsNotificationType` 枚举键从大写改为驼峰式以匹配其他枚举。
- **本地通知**
  - 此插件现在使用新版权限 API。移除了 `requestPermission()`，请使用 `requestPermissions()`。
- **推送通知**
  - 此插件现在使用新版权限 API。移除了 `requestPermission()`，请使用 `requestPermissions()`。
- **分享**
  - `share()` 方法现在返回 `ShareResult` 而非 `any`
  - `share()` 的返回值不再包含 `completed`。如果未完成，它将拒绝而非返回。
- **存储**
  - **需要数据迁移！** 内部存储机制已变更，需要数据迁移。新增了便捷方法 `migrate()`。要在不影响最终用户的情况下更新应用，请在调用其他方法前调用 `migrate()`。
- **文件系统**
  - `stat()` 方法现在在所有平台上返回以毫秒为单位的 ctime 和 mtime 时间戳。此前 iOS 返回的是以秒为单位的时间戳。

## 日志变更

Capacitor 3 中已弃用 `hideLogs` 配置选项。它被新的 `loggingBehavior` 配置选项替代。详情请参阅[配置文档](/main/reference/config.md)。

## iOS

Capacitor 3 支持 iOS 12+。需要 Xcode 12+。推荐 CocoaPods 1.8+。

### 更新 CocoaPods

建议将 CocoaPods 升级至最新稳定版本。[CocoaPods 1.8](https://blog.cocoapods.org/CocoaPods-1.8.0-beta/) 改用 CDN，这意味着不再需要定期运行 `pod repo update`。

通过 `pod --version` 检查 CocoaPods 版本，并访问 [cocoapods.org](https://cocoapods.org) 获取安装说明。

### 设置 iOS 部署目标为 12.0

为您的 Xcode 项目和应用程序目标执行以下操作：打开 **Build Settings** 标签页。在 **Deployment** 部分，将 **iOS Deployment Target** 更改为 **iOS 12.0**。

然后，打开 `ios/App/Podfile` 并将 iOS 版本更新为 12.0：

```diff
-platform :ios, '11.0'
+platform :ios, '12.0'
 use_frameworks!
```

### 设置 Swift 版本为 5

如果您的应用尚未使用 Swift 5，请在 Xcode 目标的 **Build Settings** 标签页中，将 **Swift Language Version** 更改为 **Swift 5**（位于 **Swift Compiler - Language** 部分）。

### 将 `public` 移至 iOS 目标目录

Capacitor 3 建议将 `ios/App/public` 目录移至 `ios/App/App/public`。这可以通过 Xcode 实现：

**删除现有 `public` 文件夹**

1. 展开 `App` 项目下的文件树，然后选择 `App` 组中的 `public` 文件夹。
1. 右键点击 **Delete**。当提示删除文件夹或仅移除引用时，选择 **Move to Trash**。

![删除 public 文件夹](/img/v6/docs/ios/xcode-public-delete-folder.png)

**在新位置重建 `public`**

1. 右键点击 `App` 项目内的 `App` 组，点击 **Add Files to "App"...**
1. 保留默认选项（确保创建文件夹引用而非组，并添加到 `App` 目标）。
1. 点击 **New Folder**，命名为 "public"。
1. 点击 **Create**，然后 **Add**。

![重建 public 文件夹](/img/v6/docs/ios/xcode-public-new-folder.png)

在 Xcode 中看起来可能相同，但新的 `public` 文件夹现在应相对于 `App` 组，而非项目根目录。

**在 gitignore 中添加新的 `public` 文件夹**

在 `ios/.gitignore` 中，将忽略路径从 `App/public` 更改为 `App/App/public`。此文件夹包含您的 Web 资源副本，不应提交。

```diff
 App/build
 App/Pods
-App/public
+App/App/public
 App/Podfile.lock
 xcuserdata
```

### 更新 Capacitor iOS 平台

```bash
npm install @capacitor/ios@latest-3
npx cap sync ios
```

### 在应用事件中从 `CAPBridge` 切换到 `ApplicationDelegateProxy`

在 `ios/App/App/AppDelegate.swift` 中更新以下内容：

```diff
     func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
         // 当应用通过 URL 启动时调用。可在此处添加额外处理，
         // 但如果希望 App API 支持跟踪应用 URL 打开，请保留此调用
-        return CAPBridge.handleOpenUrl(url, options)
+        return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
     }

     func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
         // 当应用通过活动（包括通用链接）启动时调用。
         // 可在此处添加额外处理，但如果希望 App API 支持
         // 跟踪应用 URL 打开，请保留此调用
-        return CAPBridge.handleContinueActivity(userActivity, restorationHandler)
+        return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
     }
```

### 移除 USE_PUSH 编译条件

如果使用推送通知功能，在 `ios/App/App/AppDelegate.swift` 中更新以下内容：

```diff

-    #if USE_PUSH

     func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
     }

     func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
     }

-#endif
```

如果不使用推送通知，可以移除整个代码块：

```diff
-    #if USE_PUSH
-
-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
-    }
-
-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
-    }
-
-#endif
```

### 从硬编码的 `CAPNotifications` 切换到 `NSNotification` 扩展

在 `ios/App/App/AppDelegate.swift` 中更新以下内容：

```diff
     override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
         super.touchesBegan(touches, with: event)

         let statusBarRect = UIApplication.shared.statusBarFrame
         guard let touchPoint = event?.allTouches?.first?.location(in: self.window) else { return }

         if statusBarRect.contains(touchPoint) {
-            NotificationCenter.default.post(CAPBridge.statusBarTappedNotification)
+            NotificationCenter.default.post(name: .capacitorStatusBarTapped, object: nil)
         }
     }

     func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
+        NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
     }

     func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
+        NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
     }
```

### 忽略 `DerivedData`

将 `DerivedData` 添加到 `ios/.gitignore` 文件。这是 Capacitor CLI 放置原生 iOS 构建的位置。

```diff
 App/Pods
 App/App/public
 App/Podfile.lock
+DerivedData
 xcuserdata

 # Capacitor 的 Cordova 插件
```

## Android

Capacitor 3 支持 Android 5+（现在也支持 Android 11）。需要 Android Studio 4+。

### 更新 Capacitor Android 平台

```bash
npm install @capacitor/android@latest-3
npx cap sync android
```

### 切换至自动加载 Android 插件

在 Capacitor 3 中，推荐自动加载 Android 插件。在 `MainActivity.java` 中，可以移除 `onCreate` 方法。当通过 npm 添加或移除插件时，您不再需要编辑此文件。

```diff
 public class MainActivity extends BridgeActivity {
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        // 初始化 Bridge
-        this.init(savedInstanceState, new ArrayList<Class<? extends Plugin>>() {{
-            // 已安装的附加插件在此处添加
-            add(Plugin1.class);
-            add(Plugin2.class);
-        }});
-    }
 }
```

如果您的应用包含专门为应用程序构建的自定义插件，您仍需在 `onCreate` 中注册这些插件：

```diff
 public class MainActivity extends BridgeActivity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

+        registerPlugin(PluginInMyApp.class);
     }
 }
```

### 更新 Gradle 