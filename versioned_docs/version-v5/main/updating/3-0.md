---
title: 升级至 3.0 版本
description: 将应用中的 Capacitor 从 v2 升级到 v3 的指南
slug: /updating/3-0
---

# 将应用中的 Capacitor 升级至 3.0 版本

Capacitor 3 为生态系统带来了重要更新和令人兴奋的新功能。

[阅读 Capacitor 3.0 发布公告 &#8250;](https://ionicframework.com/blog/announcing-capacitor-3-0/)

> 将应用升级到 Capacitor 3 后，您是否愿意在[此讨论帖](https://github.com/ionic-team/capacitor/discussions/3994)中分享反馈？我们非常期待听到您的声音！💖

如果您是插件开发者，希望将插件升级至新版 Capacitor，请参阅 [Capacitor 插件升级指南](/main/updating/plugins/3-0.md)。

## NodeJS 12+

Node 8 已终止支持。Node 10 将于 2021 年 4 月 30 日终止支持。Capacitor 3 要求 NodeJS 12 或更高版本。（推荐使用最新的 LTS 版本。）

## Ionic CLI

如果您使用 Ionic CLI，官方从 6.16.0 版本开始支持 Capacitor 3。建议通过 `npm install -g @ionic/cli` 升级至最新版本。

## 更新 Capacitor CLI 和核心包

```bash
npm install @capacitor/cli@latest-3 @capacitor/core@latest-3
```

## ES2017+

Capacitor 3 现在针对 ES2017 环境构建，而非 ES5。[插件模板也已更新](https://github.com/ionic-team/capacitor/pull/3427/files#diff-b22b3d0cbb7d8f6fdfe1f6f1d9e84b7d)以支持 ES2017，鼓励第三方插件更新其目标环境。

除非您需要支持 IE11（Capacitor 不官方支持），否则此变更不会影响您的应用。

## TypeScript 3.8+

Capacitor 3 使用了仅能在 TS 3.8 或更高版本中使用的新 TypeScript 语法。

## Capacitor 配置变更

如果您已安装 TypeScript 3.8+，可以将 `capacitor.config.json` 迁移为类型化的 TypeScript 配置文件 `capacitor.config.ts`。您仍可使用 `.json` 文件，但 TypeScript 配置文件可能为团队提供更好的开发体验。以下是 [Capacitor 测试应用](https://github.com/ionic-team/capacitor-testapp)中使用的 `capacitor.config.ts` 文件示例。

```typescript
/// <reference types="@capacitor/local-notifications" />
/// <reference types="@capacitor/push-notifications" />
/// <reference types="@capacitor/splash-screen" />

import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.capacitorjs.app.testapp',
  appName: 'capacitor-testapp',
  webDir: 'build',
  plugins: {
    SplashScreen: {
      launchAutoHide: false,
    },
    LocalNotifications: {
      smallIcon: 'ic_stat_icon_config_sample',
      iconColor: '#CE0B7C',
    },
    PushNotifications: {
      presentationOptions: ['alert', 'sound'],
    },
  },
};

export default config;
```

## 官方插件

所有插件已从 Capacitor 核心中移除并放入各自的 npm 包。这样做有几个原因（参见 [#3227](https://github.com/ionic-team/capacitor/issues/3227)），核心团队确信这是正确的方式。您可以像这样导入核心插件。

```typescript
import { Camera } from '@capacitor/camera';
```

### 移除了后台任务、权限和照片插件

- **后台任务**：此插件似乎很少使用，且不完全符合大多数开发者的预期。核心团队将在未来重新考虑后台功能。关注 [#3032](https://github.com/ionic-team/capacitor/issues/3032) 获取更新。
- **权限**：核心团队已实现了一种替代这种集中式方法的新方案，社区插件也可采用（参见[新权限 API](/plugins/creating-plugins/web-guide.md#permissions)）。
- **照片**：这个未记录的仅限 iOS 的插件已被移除。使用 [`@capacitor-community/media`](https://github.com/capacitor-community/media)。

### 拆分无障碍、应用和模态插件

- **无障碍**
  - VoiceOver 和 TalkBack 功能移至 [**屏幕阅读器**](/apis/screen-reader.md)
- **应用**
  - 与应用相关的信息和功能保留在 [**应用**](/apis/app.md)
  - 应用 URL 处理（`openUrl()` 和 `canOpenUrl()`）移至 [**应用启动器**](/apis/app-launcher.md)
- **模态**
  - 操作表功能（`showActions()`）移至 [**操作表**](/apis/action-sheet.md)
  - 对话框功能（`alert()`、`prompt()` 和 `confirm()`）移至 [**对话框**](/apis/dialog.md)

### 迁移应用以使用新的官方插件包

此变更需要您单独安装每个正在使用的插件。

1. 在项目中搜索从 `@capacitor/core` 的 `Plugins` 对象提取的核心插件
1. 查找相应的[插件文档](/plugins/official.md)，注意[部分插件已被拆分](#拆分无障碍、应用和模态插件)
1. 按照文档中的安装说明安装每个插件
1. 将插件导入更改为从插件包导入（参见[插件导入](#插件导入)）
1. 遵循[向后不兼容的插件变更](#向后不兼容的插件变更)中的说明

**使用 Ionic Framework？**

Ionic Framework 使用了以下插件中的 API：

- [**应用**](/apis/app.md)
- [**触觉反馈**](/apis/haptics.md)
- [**键盘**](/apis/keyboard.md)
- [**状态栏**](/apis/status-bar.md)

为了获得 Ionic Framework 的最佳用户体验，即使您未在应用中导入这些插件，也应确保它们已安装：

```bash
npm install @capacitor/app @capacitor/haptics @capacitor/keyboard @capacitor/status-bar
```

## 插件导入

已弃用 `Plugins` 对象，但在 Capacitor 3 中仍可继续工作。Capacitor 插件应更新以使用新的插件注册 API（参见[插件升级指南](/main/updating/plugins/3-0.md)），这将允许它们直接从插件包导入。

今后，不应再使用来自 `@capacitor/core` 的 `Plugins` 对象。

```typescript
// 旧方式
import { Plugins } from '@capacitor/core';
const { AnyPlugin } = Plugins;
```

首选从插件包直接导入插件，但插件必须更新至 Capacitor 3 才能实现此功能。

```typescript
// 新方式
import { AnyPlugin } from 'any-plugin';
```

## 向后不兼容的插件变更

尽管许多插件 API 保持不变以简化迁移至 Capacitor 3 的过程，但有些需要代码更新和手动迁移。

- **无障碍** / **屏幕阅读器**
  - `isScreenReaderEnabled()` 方法已重命名为 `isEnabled()`
  - `'accessibilityScreenReaderStateChange'` 事件已重命名为 `'stateChange'`
  - 在 Android 和 iOS 上，`speak()` 仅在屏幕阅读器当前激活时有效。对于无论屏幕阅读器是否激活的文本转语音功能，请使用 [`@capacitor-community/text-to-speech`](https://github.com/capacitor-community/text-to-speech)。
- **浏览器**
  - 已移除 `prefetch()`。
- **设备**
  - 应用信息已从 `getInfo()` 中移除（`appVersion`、`appBuild`、`appId` 和 `appName`）。使用 App 插件的 [`getInfo()`](/apis/app.md#getinfo) 获取此信息。
  - `uuid` 已从 `getInfo()` 中移除。使用新的 `getId()` 函数。
- **触觉反馈**
  - `HapticsNotificationType` 枚举键已从大写改为驼峰式以匹配其他枚举。
- **本地通知**
  - 此插件现在使用新的权限 API。`requestPermission()` 已移除，请使用 `requestPermissions()`。
- **推送通知**
  - 此插件现在使用新的权限 API。`requestPermission()` 已移除，请使用 `requestPermissions()`。
- **分享**
  - `share()` 方法现在返回 `ShareResult` 而非 `any`
  - `share()` 的返回值将不再包含 `completed`。如果未完成，它将拒绝。
- **存储**
  - **需要数据迁移！** 内部存储机制已变更，需要数据迁移。已添加便捷方法：`migrate()`。要在不影响最终用户的情况下更新应用，请在调用其他方法之前调用 `migrate()`。
- **文件系统**
  - `stat()` 方法现在在所有平台上返回以毫秒为单位的 ctime 和 mtime 时间戳。之前，iOS 返回的时间戳以秒为单位。

## 日志变更

Capacitor 3 中已弃用 `hideLogs` 配置选项。它已被新的 `loggingBehavior` 配置选项取代。详细信息可在[配置文档](/main/reference/config.md)中找到。

## iOS

Capacitor 3 支持 iOS 12+。需要 Xcode 12+。推荐使用 CocoaPods 1.8+。

### 更新 CocoaPods

建议将 CocoaPods 升级至最新稳定版本。[CocoaPods 1.8](https://blog.cocoapods.org/CocoaPods-1.8.0-beta/) 改用 CDN，这意味着不再需要定期运行 `pod repo update`。

使用 `pod --version` 检查 CocoaPods 版本，并访问 [cocoapods.org](https://cocoapods.org) 获取安装说明。

### 设置 iOS 部署目标为 12.0

对您的 Xcode 项目和应用程序目标执行以下操作：打开 **Build Settings** 选项卡。在 **Deployment** 部分，将 **iOS Deployment Target** 更改为 **iOS 12.0**。

然后，打开 `ios/App/Podfile` 并将 iOS 版本更新为 12.0：

```diff
-platform :ios, '11.0'
+platform :ios, '12.0'
 use_frameworks!
```

### 设置 Swift 版本为 5

如果您的应用尚未使用 Swift 5，请在 Xcode 目标的 **Build Settings** 选项卡中，将 **Swift Language Version** 更改为 **Swift 5**（位于 **Swift Compiler - Language** 部分）。

### 将 `public` 移至 iOS 目标目录

Capacitor 3 推荐将 `ios/App/public` 目录移至 `ios/App/App/public`。这可以在 Xcode 中完成：

**删除现有的 `public` 文件夹**

1. 展开 `App` 项目下的文件树，然后选择 `App` 组，再选择 `public` 文件夹。
1. 右键点击 **Delete**。当提示删除文件夹或仅删除引用时，选择 **Move to Trash**。

![删除 public 文件夹](../../../../static/img/v5/docs/ios/xcode-public-delete-folder.png)

**在新位置重新创建 `public`**

1. 右键点击 `App` 项目内的 `App` 组，然后点击 **Add Files to "App"...**
1. 保留默认选项（确保创建文件夹引用而非组，并添加到 `App` 目标）。
1. 点击 **New Folder**，命名为 "public"。
1. 点击 **Create**，然后点击 **Add**。

![重新创建 public 文件夹](../../../../static/img/v5/docs/ios/xcode-public-new-folder.png)

在 Xcode 中它可能看起来相同，但新的 `public` 文件夹现在应相对于 `App` 组，而非项目根目录。

**gitignore 新的 `public` 文件夹**

在 `ios/.gitignore` 中，将忽略路径从 `App/public` 更改为 `App/App/public`。此文件夹包含您的 Web 资产副本，不应提交。

```diff
 App/build
 App/Pods
-App/public
+App/App/public
 App/Podfile.lock
 xcuserdata
```

### 更新 Capacitor iOS 平台

```bash
npm install @capacitor/ios@latest-3
npx cap sync ios
```

### 在应用事件中从 `CAPBridge` 切换到 `ApplicationDelegateProxy`

在 `ios/App/App/AppDelegate.swift` 中更新以下内容：

```diff
     func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
         // Called when the app was launched with a url. Feel free to add additional processing here,
         // but if you want the App API to support tracking app url opens, make sure to keep this call
-        return CAPBridge.handleOpenUrl(url, options)
+        return ApplicationDelegateProxy.shared.application(app, open: url, options: options)
     }

     func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
         // Called when the app was launched with an activity, including Universal Links.
         // Feel free to add additional processing here, but if you want the App API to support
         // tracking app url opens, make sure to keep this call
-        return CAPBridge.handleContinueActivity(userActivity, restorationHandler)
+        return ApplicationDelegateProxy.shared.application(application, continue: userActivity, restorationHandler: restorationHandler)
     }
```

### 移除 USE_PUSH 编译条件

如果使用推送通知功能，在 `ios/App/App/AppDelegate.swift` 中更新以下内容：

```diff

-    #if USE_PUSH

     func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
     }

     func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
     }

-#endif
```

如果不使用推送通知，可以移除整个代码块：

```diff
-    #if USE_PUSH
-
-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
-    }
-
-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
-    }
-
-#endif
```

### 从硬编码的 `CAPNotifications` 切换到 `NSNotification` 扩展

在 `ios/App/App/AppDelegate.swift` 中更新以下内容：

```diff
     override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
         super.touchesBegan(touches, with: event)

         let statusBarRect = UIApplication.shared.statusBarFrame
         guard let touchPoint = event?.allTouches?.first?.location(in: self.window) else { return }

         if statusBarRect.contains(touchPoint) {
-            NotificationCenter.default.post(CAPBridge.statusBarTappedNotification)
+            NotificationCenter.default.post(name: .capacitorStatusBarTapped, object: nil)
         }
     }

     func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidRegisterForRemoteNotificationsWithDeviceToken.name()), object: deviceToken)
+        NotificationCenter.default.post(name: .capacitorDidRegisterForRemoteNotifications, object: deviceToken)
     }

     func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
-        NotificationCenter.default.post(name: Notification.Name(CAPNotifications.DidFailToRegisterForRemoteNotificationsWithError.name()), object: error)
+        NotificationCenter.default.post(name: .capacitorDidFailToRegisterForRemoteNotifications, object: error)
     }
```

### 忽略 `DerivedData`

将 `DerivedData` 添加到 `ios/.gitignore` 文件中。这是 Capacitor CLI 放置原生 iOS 构建的位置。

```diff
 App/Pods
 App/App/public
 App/Podfile.lock
+DerivedData
 xcuserdata

 # Cordova plugins for Capacitor
```

## Android

Capacitor 3 支持 Android 5+（现在支持 Android 11）。需要 Android Studio 4+。

### 更新 Capacitor Android 平台

```bash
npm install @capacitor/android@latest-3
npx cap sync android
```

### 切换到自动加载 Android 插件

在 Capacitor 3 中，首选自动加载 Android 插件。在 `MainActivity.java` 中，可以移除 `onCreate` 方法。添加或移除通过 npm 安装的插件时，您不再需要编辑此文件。

```diff
 public class MainActivity extends BridgeActivity {
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        // Initializes the Bridge
-        this.init(savedInstanceState, new ArrayList<Class<? extends Plugin>>() {{
-            // Additional plugins you've installed go here
-            add(Plugin1.class);
-            add(Plugin2.class);
-        }});
-    }
 }
```

如果您的应用包含专为应用构建的自定义插件，您仍然需要在 `onCreate` 中注册这些插件：

```diff
 public class MainActivity extends BridgeActivity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

+        register